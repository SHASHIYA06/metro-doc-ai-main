// Enhanced Export Service for KMRCL Metro Document Intelligence
// Supports PDF, Word (DOCX), and Excel (XLSX) export formats

import jsPDF from 'jspdf';
import * as XLSX from 'xlsx';

export interface ExportData {
  title: string;
  summary: string;
  results: Array<{
    id: string;
    title: string;
    content: string;
    system: string;
    subsystem: string;
    score: number;
    fileType: string;
    sources?: Array<{
      fileName: string;
      preview: string;
    }>;
  }>;
  analysisResult?: {
    summary: string;
    technical_details: string;
    wire_details: Array<{ number: string; specification: string }>;
    components: Array<{ type: string; part_number: string }>;
    system_architecture: {
      name: string;
      version: string;
      modules: string[];
    };
  };
  metadata: {
    searchQuery: string;
    timestamp: string;
    totalResults: number;
    generatedBy: string;
  };
}

class ExportService {
  /**
   * Export data as PDF with professional formatting
   */
  async exportToPDF(data: ExportData): Promise<void> {
    try {
      const doc = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a4'
      });

      let yPosition = 20;
      const pageWidth = doc.internal.pageSize.getWidth();
      const margin = 20;
      const contentWidth = pageWidth - (margin * 2);

      // Header
      doc.setFontSize(20);
      doc.setFont('helvetica', 'bold');
      doc.setTextColor(30, 58, 138); // Blue color
      doc.text('KMRCL Metro Document Intelligence', margin, yPosition);
      yPosition += 10;

      doc.setFontSize(16);
      doc.setFont('helvetica', 'normal');
      doc.setTextColor(0, 0, 0);
      doc.text(data.title, margin, yPosition);
      yPosition += 15;

      // Metadata
      doc.setFontSize(10);
      doc.setTextColor(100, 100, 100);
      doc.text(`Search Query: ${data.metadata.searchQuery}`, margin, yPosition);
      yPosition += 5;
      doc.text(`Generated: ${data.metadata.timestamp}`, margin, yPosition);
      yPosition += 5;
      doc.text(`Total Results: ${data.metadata.totalResults}`, margin, yPosition);
      yPosition += 5;
      doc.text(`Generated by: ${data.metadata.generatedBy}`, margin, yPosition);
      yPosition += 15;

      // Summary
      if (data.summary) {
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(0, 0, 0);
        doc.text('Executive Summary', margin, yPosition);
        yPosition += 8;

        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        const summaryLines = doc.splitTextToSize(data.summary, contentWidth);
        doc.text(summaryLines, margin, yPosition);
        yPosition += summaryLines.length * 4 + 10;
      }

      // Analysis Results
      if (data.analysisResult) {
        this.addAnalysisSection(doc, data.analysisResult, margin, yPosition, contentWidth);
        yPosition += 60; // Approximate space for analysis section
      }

      // Search Results
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text('Search Results', margin, yPosition);
      yPosition += 10;

      data.results.forEach((result, index) => {
        // Check if we need a new page
        if (yPosition > 250) {
          doc.addPage();
          yPosition = 20;
        }

        // Result header
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(30, 58, 138);
        doc.text(`${index + 1}. ${result.title}`, margin, yPosition);
        yPosition += 8;

        // Result details
        doc.setFontSize(9);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(0, 0, 0);
        doc.text(`System: ${result.system} | Subsystem: ${result.subsystem} | Match: ${Math.round(result.score * 100)}%`, margin, yPosition);
        yPosition += 6;

        // Content
        const contentLines = doc.splitTextToSize(result.content, contentWidth);
        doc.text(contentLines, margin, yPosition);
        yPosition += contentLines.length * 4 + 8;

        // Sources
        if (result.sources && result.sources.length > 0) {
          doc.setFontSize(8);
          doc.setTextColor(100, 100, 100);
          doc.text('Sources:', margin, yPosition);
          yPosition += 4;
          
          result.sources.forEach(source => {
            doc.text(`• ${source.fileName}`, margin + 5, yPosition);
            yPosition += 3;
          });
          yPosition += 5;
        }
      });

      // Footer
      const pageCount = doc.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor(100, 100, 100);
        doc.text(`Page ${i} of ${pageCount}`, pageWidth - 30, doc.internal.pageSize.getHeight() - 10);
        doc.text('KMRCL Metro Document Intelligence', margin, doc.internal.pageSize.getHeight() - 10);
      }

      // Save the PDF
      doc.save(`KMRCL_Search_Results_${new Date().toISOString().split('T')[0]}.pdf`);
    } catch (error) {
      console.error('Error exporting to PDF:', error);
      throw new Error('Failed to export PDF');
    }
  }

  /**
   * Export data as Word document (DOCX)
   */
  async exportToWord(data: ExportData): Promise<void> {
    try {
      // Create HTML content for Word export
      let htmlContent = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <title>${data.title}</title>
          <style>
            body { font-family: Arial, sans-serif; margin: 40px; }
            .header { color: #1e3a8a; border-bottom: 2px solid #1e3a8a; padding-bottom: 10px; }
            .metadata { background-color: #f3f4f6; padding: 15px; margin: 20px 0; }
            .section { margin: 20px 0; }
            .result { border-left: 4px solid #3b82f6; padding-left: 15px; margin: 15px 0; }
            .analysis { background-color: #eff6ff; padding: 15px; border-radius: 5px; }
            table { width: 100%; border-collapse: collapse; margin: 10px 0; }
            th, td { border: 1px solid #d1d5db; padding: 8px; text-align: left; }
            th { background-color: #f9fafb; }
          </style>
        </head>
        <body>
          <div class="header">
            <h1>KMRCL Metro Document Intelligence</h1>
            <h2>${data.title}</h2>
          </div>
          
          <div class="metadata">
            <p><strong>Search Query:</strong> ${data.metadata.searchQuery}</p>
            <p><strong>Generated:</strong> ${data.metadata.timestamp}</p>
            <p><strong>Total Results:</strong> ${data.metadata.totalResults}</p>
            <p><strong>Generated by:</strong> ${data.metadata.generatedBy}</p>
          </div>
      `;

      if (data.summary) {
        htmlContent += `
          <div class="section">
            <h3>Executive Summary</h3>
            <p>${data.summary}</p>
          </div>
        `;
      }

      if (data.analysisResult) {
        htmlContent += this.generateAnalysisHTML(data.analysisResult);
      }

      htmlContent += `
        <div class="section">
          <h3>Search Results</h3>
      `;

      data.results.forEach((result, index) => {
        htmlContent += `
          <div class="result">
            <h4>${index + 1}. ${result.title}</h4>
            <p><strong>System:</strong> ${result.system} | <strong>Subsystem:</strong> ${result.subsystem} | <strong>Match:</strong> ${Math.round(result.score * 100)}%</p>
            <p>${result.content}</p>
        `;

        if (result.sources && result.sources.length > 0) {
          htmlContent += '<p><strong>Sources:</strong></p><ul>';
          result.sources.forEach(source => {
            htmlContent += `<li>${source.fileName}</li>`;
          });
          htmlContent += '</ul>';
        }

        htmlContent += '</div>';
      });

      htmlContent += `
          </div>
        </body>
        </html>
      `;

      // Create and download the Word document
      const blob = new Blob([htmlContent], { 
        type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
      });
      
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `KMRCL_Search_Results_${new Date().toISOString().split('T')[0]}.doc`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Error exporting to Word:', error);
      throw new Error('Failed to export Word document');
    }
  }

  /**
   * Export data as Excel spreadsheet (XLSX)
   */
  async exportToExcel(data: ExportData): Promise<void> {
    try {
      const workbook = XLSX.utils.book_new();

      // Summary Sheet
      const summaryData = [
        ['KMRCL Metro Document Intelligence'],
        ['Report Title', data.title],
        ['Search Query', data.metadata.searchQuery],
        ['Generated', data.metadata.timestamp],
        ['Total Results', data.metadata.totalResults],
        ['Generated by', data.metadata.generatedBy],
        [],
        ['Executive Summary'],
        [data.summary || 'No summary available']
      ];

      const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
      XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

      // Results Sheet
      const resultsData = [
        ['#', 'Title', 'System', 'Subsystem', 'Match %', 'File Type', 'Content', 'Sources']
      ];

      data.results.forEach((result, index) => {
        const sources = result.sources ? result.sources.map(s => s.fileName).join('; ') : '';
        resultsData.push([
          index + 1,
          result.title,
          result.system,
          result.subsystem,
          Math.round(result.score * 100),
          result.fileType,
          result.content,
          sources
        ]);
      });

      const resultsSheet = XLSX.utils.aoa_to_sheet(resultsData);
      
      // Auto-size columns
      const colWidths = [
        { wch: 5 },   // #
        { wch: 30 },  // Title
        { wch: 15 },  // System
        { wch: 15 },  // Subsystem
        { wch: 10 },  // Match %
        { wch: 10 },  // File Type
        { wch: 50 },  // Content
        { wch: 30 }   // Sources
      ];
      resultsSheet['!cols'] = colWidths;

      XLSX.utils.book_append_sheet(workbook, resultsSheet, 'Search Results');

      // Analysis Sheet (if available)
      if (data.analysisResult) {
        const analysisData = [
          ['Technical Analysis'],
          [],
          ['Summary', data.analysisResult.summary],
          ['Technical Details', data.analysisResult.technical_details],
          [],
          ['System Architecture'],
          ['Name', data.analysisResult.system_architecture.name],
          ['Version', data.analysisResult.system_architecture.version],
          ['Modules', data.analysisResult.system_architecture.modules.join(', ')],
          [],
          ['Components']
        ];

        // Add components
        analysisData.push(['Type', 'Part Number']);
        data.analysisResult.components.forEach(component => {
          analysisData.push([component.type, component.part_number]);
        });

        analysisData.push([], ['Wire Details']);
        analysisData.push(['Wire Number', 'Specification']);
        data.analysisResult.wire_details.forEach(wire => {
          analysisData.push([wire.number, wire.specification]);
        });

        const analysisSheet = XLSX.utils.aoa_to_sheet(analysisData);
        XLSX.utils.book_append_sheet(workbook, analysisSheet, 'Technical Analysis');
      }

      // Save the Excel file
      XLSX.writeFile(workbook, `KMRCL_Search_Results_${new Date().toISOString().split('T')[0]}.xlsx`);
    } catch (error) {
      console.error('Error exporting to Excel:', error);
      throw new Error('Failed to export Excel file');
    }
  }

  /**
   * Add analysis section to PDF
   */
  private addAnalysisSection(doc: jsPDF, analysis: any, margin: number, yPos: number, contentWidth: number): void {
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text('Technical Analysis', margin, yPos);
    yPos += 10;

    // System Architecture
    doc.setFontSize(12);
    doc.text('System Architecture', margin, yPos);
    yPos += 6;

    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    doc.text(`Name: ${analysis.system_architecture.name}`, margin, yPos);
    yPos += 4;
    doc.text(`Version: ${analysis.system_architecture.version}`, margin, yPos);
    yPos += 4;
    doc.text(`Modules: ${analysis.system_architecture.modules.join(', ')}`, margin, yPos);
    yPos += 8;

    // Components (if any)
    if (analysis.components.length > 0) {
      doc.setFontSize(12);
      doc.setFont('helvetica', 'bold');
      doc.text('Components', margin, yPos);
      yPos += 6;

      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');
      analysis.components.slice(0, 5).forEach((component: any) => {
        doc.text(`• ${component.type}: ${component.part_number}`, margin, yPos);
        yPos += 4;
      });
    }
  }

  /**
   * Generate HTML for analysis section in Word export
   */
  private generateAnalysisHTML(analysis: any): string {
    let html = `
      <div class="section analysis">
        <h3>Technical Analysis</h3>
        <h4>System Architecture</h4>
        <p><strong>Name:</strong> ${analysis.system_architecture.name}</p>
        <p><strong>Version:</strong> ${analysis.system_architecture.version}</p>
        <p><strong>Modules:</strong> ${analysis.system_architecture.modules.join(', ')}</p>
    `;

    if (analysis.components.length > 0) {
      html += `
        <h4>Components</h4>
        <table>
          <tr><th>Type</th><th>Part Number</th></tr>
      `;
      analysis.components.forEach((component: any) => {
        html += `<tr><td>${component.type}</td><td>${component.part_number}</td></tr>`;
      });
      html += '</table>';
    }

    if (analysis.wire_details.length > 0) {
      html += `
        <h4>Wire Details</h4>
        <table>
          <tr><th>Wire Number</th><th>Specification</th></tr>
      `;
      analysis.wire_details.forEach((wire: any) => {
        html += `<tr><td>${wire.number}</td><td>${wire.specification}</td></tr>`;
      });
      html += '</table>';
    }

    html += '</div>';
    return html;
  }
}

// Export singleton instance
export const exportService = new ExportService();

// Export types and class
export { ExportService };