// Export Service for AI Search Results
// Supports PDF, Excel, and Word export formats

import jsPDF from 'jspdf';
import * as XLSX from 'xlsx';

export interface SearchResult {
  id: string;
  title: string;
  content: string;
  system: string;
  subsystem: string;
  score: number;
  preview: string;
  sources: Array<{
    fileName: string;
    score: number;
    preview: string;
  }>;
}

export interface ExportData {
  query: string;
  results: SearchResult[];
  timestamp: string;
  selectedFile?: string;
  totalResults: number;
}

class ExportService {
  // Export to PDF
  async exportToPDF(data: ExportData): Promise<void> {
    try {
      console.log('üìÑ Exporting search results to PDF...');
      
      const pdf = new jsPDF();
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const margin = 20;
      const lineHeight = 7;
      let yPosition = margin;

      // Helper function to add text with word wrapping
      const addWrappedText = (text: string, x: number, y: number, maxWidth: number, fontSize: number = 12): number => {
        pdf.setFontSize(fontSize);
        const lines = pdf.splitTextToSize(text, maxWidth);
        
        for (let i = 0; i < lines.length; i++) {
          if (y + (i * lineHeight) > pageHeight - margin) {
            pdf.addPage();
            y = margin;
          }
          pdf.text(lines[i], x, y + (i * lineHeight));
        }
        
        return y + (lines.length * lineHeight);
      };

      // Header
      pdf.setFontSize(20);
      pdf.setFont('helvetica', 'bold');
      pdf.text('AI Search Results Export', margin, yPosition);
      yPosition += 15;

      // Query information
      pdf.setFontSize(12);
      pdf.setFont('helvetica', 'normal');
      yPosition = addWrappedText(`Search Query: ${data.query}`, margin, yPosition, pageWidth - 2 * margin);
      yPosition += 5;
      
      if (data.selectedFile) {
        yPosition = addWrappedText(`Selected File: ${data.selectedFile}`, margin, yPosition, pageWidth - 2 * margin);
        yPosition += 5;
      }
      
      yPosition = addWrappedText(`Export Date: ${data.timestamp}`, margin, yPosition, pageWidth - 2 * margin);
      yPosition += 5;
      yPosition = addWrappedText(`Total Results: ${data.totalResults}`, margin, yPosition, pageWidth - 2 * margin);
      yPosition += 15;

      // Results
      data.results.forEach((result, index) => {
        // Check if we need a new page
        if (yPosition > pageHeight - 100) {
          pdf.addPage();
          yPosition = margin;
        }

        // Result header
        pdf.setFontSize(14);
        pdf.setFont('helvetica', 'bold');
        yPosition = addWrappedText(`${index + 1}. ${result.title}`, margin, yPosition, pageWidth - 2 * margin, 14);
        yPosition += 5;

        // Metadata
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'italic');
        yPosition = addWrappedText(`System: ${result.system} | Subsystem: ${result.subsystem} | Relevance: ${Math.round(result.score * 100)}%`, margin, yPosition, pageWidth - 2 * margin, 10);
        yPosition += 8;

        // Content
        pdf.setFontSize(11);
        pdf.setFont('helvetica', 'normal');
        const cleanContent = result.content.replace(/<[^>]*>/g, '').replace(/\n\s*\n/g, '\n');
        yPosition = addWrappedText(cleanContent, margin, yPosition, pageWidth - 2 * margin, 11);
        yPosition += 10;

        // Sources
        if (result.sources && result.sources.length > 0) {
          pdf.setFontSize(9);
          pdf.setFont('helvetica', 'italic');
          const sourcesText = `Sources: ${result.sources.map(s => s.fileName).join(', ')}`;
          yPosition = addWrappedText(sourcesText, margin, yPosition, pageWidth - 2 * margin, 9);
          yPosition += 10;
        }

        // Separator line
        if (index < data.results.length - 1) {
          pdf.setDrawColor(200, 200, 200);
          pdf.line(margin, yPosition, pageWidth - margin, yPosition);
          yPosition += 10;
        }
      });

      // Footer
      const totalPages = pdf.internal.getNumberOfPages();
      for (let i = 1; i <= totalPages; i++) {
        pdf.setPage(i);
        pdf.setFontSize(8);
        pdf.setFont('helvetica', 'normal');
        pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin - 30, pageHeight - 10);
        pdf.text('Generated by AI Search System', margin, pageHeight - 10);
      }

      // Save the PDF
      const fileName = `AI_Search_Results_${data.query.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`;
      pdf.save(fileName);
      
      console.log('‚úÖ PDF export completed:', fileName);
    } catch (error) {
      console.error('‚ùå PDF export failed:', error);
      throw new Error(`PDF export failed: ${error.message}`);
    }
  }

  // Export to Excel
  async exportToExcel(data: ExportData): Promise<void> {
    try {
      console.log('üìä Exporting search results to Excel...');
      
      const workbook = XLSX.utils.book_new();

      // Summary sheet
      const summaryData = [
        ['AI Search Results Export'],
        [''],
        ['Search Query', data.query],
        ['Selected File', data.selectedFile || 'All files'],
        ['Export Date', data.timestamp],
        ['Total Results', data.totalResults],
        [''],
        ['Summary Statistics'],
        ['Average Relevance Score', data.results.length > 0 ? (data.results.reduce((sum, r) => sum + r.score, 0) / data.results.length * 100).toFixed(2) + '%' : '0%'],
        ['Highest Score', data.results.length > 0 ? (Math.max(...data.results.map(r => r.score)) * 100).toFixed(2) + '%' : '0%'],
        ['Lowest Score', data.results.length > 0 ? (Math.min(...data.results.map(r => r.score)) * 100).toFixed(2) + '%' : '0%']
      ];

      const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
      XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');

      // Results sheet
      const resultsData = [
        ['#', 'Title', 'System', 'Subsystem', 'Relevance Score', 'Content Preview', 'Sources', 'Full Content']
      ];

      data.results.forEach((result, index) => {
        const cleanContent = result.content.replace(/<[^>]*>/g, '').replace(/\n\s*\n/g, '\n');
        const sources = result.sources.map(s => s.fileName).join(', ');
        
        resultsData.push([
          index + 1,
          result.title,
          result.system,
          result.subsystem,
          Math.round(result.score * 100) + '%',
          result.preview,
          sources,
          cleanContent
        ]);
      });

      const resultsSheet = XLSX.utils.aoa_to_sheet(resultsData);
      
      // Set column widths
      resultsSheet['!cols'] = [
        { width: 5 },   // #
        { width: 30 },  // Title
        { width: 20 },  // System
        { width: 20 },  // Subsystem
        { width: 15 },  // Score
        { width: 40 },  // Preview
        { width: 30 },  // Sources
        { width: 60 }   // Full Content
      ];

      XLSX.utils.book_append_sheet(workbook, resultsSheet, 'Results');

      // Sources analysis sheet
      const allSources = data.results.flatMap(r => r.sources);
      const sourceStats = allSources.reduce((acc, source) => {
        acc[source.fileName] = (acc[source.fileName] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      const sourcesData = [
        ['Source File', 'Frequency', 'Percentage']
      ];

      Object.entries(sourceStats).forEach(([fileName, count]) => {
        const percentage = ((count / allSources.length) * 100).toFixed(2) + '%';
        sourcesData.push([fileName, count, percentage]);
      });

      const sourcesSheet = XLSX.utils.aoa_to_sheet(sourcesData);
      XLSX.utils.book_append_sheet(workbook, sourcesSheet, 'Source Analysis');

      // Save the Excel file
      const fileName = `AI_Search_Results_${data.query.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().split('T')[0]}.xlsx`;
      XLSX.writeFile(workbook, fileName);
      
      console.log('‚úÖ Excel export completed:', fileName);
    } catch (error) {
      console.error('‚ùå Excel export failed:', error);
      throw new Error(`Excel export failed: ${error.message}`);
    }
  }

  // Export to Word (HTML format that can be opened in Word)
  async exportToWord(data: ExportData): Promise<void> {
    try {
      console.log('üìù Exporting search results to Word format...');
      
      let htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>AI Search Results Export</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        .header { border-bottom: 2px solid #333; padding-bottom: 20px; margin-bottom: 30px; }
        .title { font-size: 24px; font-weight: bold; color: #333; margin-bottom: 10px; }
        .metadata { background-color: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .result { margin-bottom: 30px; border-bottom: 1px solid #ddd; padding-bottom: 20px; }
        .result-title { font-size: 18px; font-weight: bold; color: #2c5aa0; margin-bottom: 10px; }
        .result-meta { font-size: 12px; color: #666; margin-bottom: 10px; }
        .result-content { margin-bottom: 15px; text-align: justify; }
        .sources { font-size: 11px; color: #888; font-style: italic; }
        .score { background-color: #e8f4fd; padding: 3px 8px; border-radius: 3px; font-weight: bold; }
        @media print { body { margin: 20px; } }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">AI Search Results Export</div>
    </div>
    
    <div class="metadata">
        <p><strong>Search Query:</strong> ${this.escapeHtml(data.query)}</p>
        ${data.selectedFile ? `<p><strong>Selected File:</strong> ${this.escapeHtml(data.selectedFile)}</p>` : ''}
        <p><strong>Export Date:</strong> ${data.timestamp}</p>
        <p><strong>Total Results:</strong> ${data.totalResults}</p>
    </div>
`;

      data.results.forEach((result, index) => {
        const cleanContent = result.content.replace(/<[^>]*>/g, '').replace(/\n/g, '<br>');
        const sources = result.sources.map(s => this.escapeHtml(s.fileName)).join(', ');
        
        htmlContent += `
    <div class="result">
        <div class="result-title">${index + 1}. ${this.escapeHtml(result.title)}</div>
        <div class="result-meta">
            <strong>System:</strong> ${this.escapeHtml(result.system)} | 
            <strong>Subsystem:</strong> ${this.escapeHtml(result.subsystem)} | 
            <strong>Relevance:</strong> <span class="score">${Math.round(result.score * 100)}%</span>
        </div>
        <div class="result-content">${cleanContent}</div>
        ${sources ? `<div class="sources"><strong>Sources:</strong> ${sources}</div>` : ''}
    </div>
`;
      });

      htmlContent += `
    <div style="margin-top: 40px; text-align: center; font-size: 12px; color: #666;">
        <p>Generated by AI Search System on ${data.timestamp}</p>
    </div>
</body>
</html>`;

      // Create and download the HTML file
      const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `AI_Search_Results_${data.query.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date().toISOString().split('T')[0]}.html`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      console.log('‚úÖ Word format export completed');
    } catch (error) {
      console.error('‚ùå Word export failed:', error);
      throw new Error(`Word export failed: ${error.message}`);
    }
  }

  // Helper method to escape HTML
  private escapeHtml(text: string): string {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // Export all formats
  async exportAll(data: ExportData): Promise<void> {
    try {
      console.log('üì¶ Exporting search results in all formats...');
      
      await Promise.all([
        this.exportToPDF(data),
        this.exportToExcel(data),
        this.exportToWord(data)
      ]);
      
      console.log('‚úÖ All formats exported successfully');
    } catch (error) {
      console.error('‚ùå Export all formats failed:', error);
      throw error;
    }
  }
}

export const exportService = new ExportService();
export { ExportService };